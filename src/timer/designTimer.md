- [1. 定时器设计](#1-定时器设计)
  - [1.1. TimeWheel时间轮](#11-timewheel时间轮)
  - [1.2. 小根堆](#12-小根堆)

# 1. 定时器设计

## 1.1. TimeWheel时间轮


## 1.2. 小根堆



:question:使用小根堆遇到的问题：

> 可以参考`libevent`库中小根堆的实现

1. **连接刷新问题**，当一个连接未超时，此时又发起了第二次请求。
   - 这个时候理想的做法是修改在堆中与此次连接对应的时间节点，可是这样的话，寻找到堆中的目标节点需要时间，重新插入又需要时间，因此这种方法可以做，但是不太好
   - 可以`RAII`的思想，第二个连接到来的时候直接往堆中添加元素，对于老的，可以在超时之后进行删除，但是对应的文件描述符并不会关闭，只会减少一个计数，如果其计数为0了，那么就可以使用析构函数进行析构，使用`close(fd_)`释放连接，将连接对应的文件描述符封装为一个对象，使用引用计数判断对象的存活情况，也就是智能指针的思路，
