- [1. 定时器设计](#1-定时器设计)
  - [1.1. TimeWheel时间轮](#11-timewheel时间轮)
  - [1.2. 小根堆](#12-小根堆)

# 1. 定时器设计

## 1.1. TimeWheel时间轮


## 1.2. 小根堆

1. **插入时间复杂度：** `logn`级别
2. **删除时间复杂度：** `logn`级别
3. **查找时间复杂度：** `O(1)`

:sparkles:特点：
- 使用了智能指针管理对象的生命周期，避免在堆中二次查找修改，节约时间

:question:使用小根堆遇到的问题：

> 可以参考`libevent`库中小根堆的实现

1. **连接刷新问题**，当一个连接未超时，此时又发起了第二次请求。
   - 这个时候理想的做法是修改在堆中与此次连接对应的时间节点，可是这样的话，寻找到堆中的目标节点需要时间，重新插入又需要时间，因此这种方法可以做，但是不太好
   - 可以`RAII`的思想，第二个连接到来的时候直接往堆中添加元素，对于老的，可以在超时之后进行删除，但是对应的文件描述符并不会关闭，只会减少一个计数，如果其计数为0了，那么就可以使用析构函数进行析构，使用`close(fd_)`释放连接，将连接对应的文件描述符封装为一个对象，使用引用计数判断对象的存活情况，也就是智能指针的思路，

![](https://github.com/Hanwn/Shoot/blob/timer/pic/TimerGuard.png?raw=true)

最终采取的是通过智能指针的方式，进行垃圾回收，使用模板的方式，让定时器和具体的业务逻辑进行解耦。